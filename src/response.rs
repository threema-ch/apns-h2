//! The APNs response types

use std::fmt;

/// The response data from APNs.
#[derive(Debug)]
pub struct Response {
    /// If the notification was not successful, has the body content from APNs.
    pub error: Option<ErrorBody>,

    /// Is the value defined in the `NotificationOptions` or a new Uuid
    /// generated by APNs.
    pub apns_id: Option<String>,

    /// A unique identifier that is only available in the Development environment.
    /// Use this to query Delivery Log information for the corresponding notification.
    pub apns_unique_id: Option<String>,

    /// The HTTP response code.
    ///
    /// * 200 Success
    /// * 400 Bad request
    /// * 403 There was an error with the certificate or with the provider authentication token
    /// * 405 The request used a bad `:method` value. Only `POST` requests are supported.
    /// * 410 The device token is no longer active for the topic.
    /// * 413 The notification payload was too large.
    /// * 429 The server received too many requests for the same device token.
    /// * 500 Internal server error.
    /// * 503 The server is shutting down and unavailable.
    pub code: u16,
}

/// The response body from APNs. Only available for errors.
#[derive(Deserialize, Debug, PartialEq, Eq)]
pub struct ErrorBody {
    /// The error indicating the reason for the failure.
    pub reason: ErrorReason,

    /// If the value of the `ErrorReason` is `Unregistered`, the value of this
    /// key is the last time at which APNs confirmed that the device token was
    /// no longer valid for the topic.
    ///
    /// Stop pushing notifications until the device registers a token with a
    /// later timestamp with your provider.
    pub timestamp: Option<u64>,
}

/// A description what went wrong with the push notification.
#[derive(Deserialize, Debug, PartialEq, Eq)]
pub enum ErrorReason {
    /// The collapse identifier exceeds the maximum allowed size.
    BadCollapseId,

    /// The specified device token is invalid. Verify that the request contains a valid token and that the token matches the environment.
    BadDeviceToken,

    /// The apns-expiration value is invalid.
    BadExpirationDate,

    /// The apns-id value is invalid.
    BadMessageId,

    /// The apns-priority value is invalid.
    BadPriority,

    /// The apns-topic value is invalid.
    BadTopic,

    /// The device token doesn’t match the specified topic.
    DeviceTokenNotForTopic,

    /// One or more headers are repeated.
    DuplicateHeaders,

    /// Idle timeout.
    IdleTimeout,

    /// The apns-push-type value is invalid.
    InvalidPushType,

    /// The device token isn’t specified in the request :path. Verify that the :path header contains the device token.
    MissingDeviceToken,

    /// The apns-topic header of the request isn’t specified and is required. The apns-topic header is mandatory when the client is connected using a certificate that supports multiple topics.
    MissingTopic,

    /// The message payload is empty.
    PayloadEmpty,

    /// Pushing to this topic is not allowed.
    TopicDisallowed,

    /// The certificate is invalid.
    BadCertificate,

    /// The client certificate doesn’t match the environment.
    BadCertificateEnvironment,

    /// The provider token is stale and a new token should be generated.
    ExpiredProviderToken,

    /// The specified action is not allowed.
    Forbidden,

    /// The provider token is not valid, or the token signature can’t be verified.
    InvalidProviderToken,

    /// No provider certificate was used to connect to APNs, and the authorization header is missing or no provider token is specified.
    MissingProviderToken,

    /// The key ID in the provider token isn’t related to the key ID of the token used in the first push of this connection. To use this token, open a new connection.
    UnrelatedKeyIdInToken,

    /// The key ID in the provider token doesn’t match the environment.
    BadEnvironmentKeyIdInToken,

    /// The request contained an invalid :path value.
    BadPath,

    /// The specified :method value isn’t POST.
    MethodNotAllowed,

    /// The device token has expired.
    ExpiredToken,

    /// The device token is inactive for the specified topic. There is no need to send further pushes to the same device token, unless your application retrieves the same device token, refer to Registering your app with APNs
    Unregistered,

    /// The message payload is too large. For information about the allowed payload size, refer to Create a POST request to APNs in Sending notification requests to APNs.
    PayloadTooLarge,

    /// The provider’s authentication token is being updated too often. Update the authentication token no more than once every 20 minutes.
    TooManyProviderTokenUpdates,

    /// Too many requests were made consecutively to the same device token.
    TooManyRequests,

    /// An internal server error occurred.
    InternalServerError,

    /// The service is unavailable.
    ServiceUnavailable,

    /// The APNs server is shutting down.
    Shutdown,
}

impl fmt::Display for ErrorReason {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match *self {
            ErrorReason::BadCollapseId => "The collapse identifier exceeds the maximum allowed size.",
            ErrorReason::BadDeviceToken => {
                "The specified device token was bad. Verify that the request contains a valid token and that the token matches the environment."
            }
            ErrorReason::BadExpirationDate => "The `apns_expiration` in `NotificationOptions` is bad.",
            ErrorReason::BadMessageId => "The `apns_id` in `NotificationOptions` is bad.",
            ErrorReason::BadPriority => "The `apns_priority` in `NotificationOptions` is bad.",
            ErrorReason::BadTopic => "The `apns_topic` in `NotificationOptions` is bad.",
            ErrorReason::DeviceTokenNotForTopic => "The device token does not match the specified topic.",
            ErrorReason::DuplicateHeaders => "One or more headers were repeated.",
            ErrorReason::IdleTimeout => "Idle time out.",
            ErrorReason::InvalidPushType => "The apns-push-type value is invalid.",
            ErrorReason::MissingDeviceToken => "The device token is not specified in the payload.",
            ErrorReason::MissingTopic => {
                "The `apns_topic` of the `NotificationOptions` was not specified and was required. The `apns_topic` header is mandatory when the client is connected using the `CertificateConnector` and the included PKCS12 file includes multiple topics, or when using the `TokenConnector`."
            }
            ErrorReason::PayloadEmpty => "The message payload was empty.",
            ErrorReason::TopicDisallowed => "Pushing to this topic is not allowed.",
            ErrorReason::BadCertificate => "The certificate was bad.",
            ErrorReason::BadCertificateEnvironment => "The client certificate was for the wrong environment.",
            ErrorReason::ExpiredProviderToken => "The provider token is stale and a new token should be generated.",
            ErrorReason::Forbidden => "The specified action is not allowed.",
            ErrorReason::InvalidProviderToken => {
                "The provider token is not valid or the token signature could not be verified."
            }
            ErrorReason::MissingProviderToken => {
                "No provider certificate was used to connect to APNs and Authorization header was missing or no provider token was specified."
            }
            ErrorReason::UnrelatedKeyIdInToken => {
                "The key ID in the provider token isn't related to the key ID of the token used in the first push of this connection."
            }
            ErrorReason::BadEnvironmentKeyIdInToken => {
                "The key ID in the provider token doesn't match the environment."
            }
            ErrorReason::BadPath => "The request path value is bad.",
            ErrorReason::MethodNotAllowed => "The request method was not `POST`.",
            ErrorReason::ExpiredToken => "The device token has expired.",
            ErrorReason::Unregistered => {
                "The device token is inactive for the specified topic. You should stop sending notifications to this token."
            }
            ErrorReason::PayloadTooLarge => "The message payload was too large (4096 bytes)",
            ErrorReason::TooManyProviderTokenUpdates => "The provider token is being updated too often.",
            ErrorReason::TooManyRequests => "Too many requests were made consecutively to the same device token.",
            ErrorReason::InternalServerError => "An internal server error occurred.",
            ErrorReason::ServiceUnavailable => "The service is unavailable.",
            ErrorReason::Shutdown => "The server is shutting down.",
        };

        f.write_str(s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_error_response_parsing() {
        let errors = vec![
            (ErrorReason::BadCollapseId, "BadCollapseId", None),
            (ErrorReason::BadDeviceToken, "BadDeviceToken", None),
            (ErrorReason::BadExpirationDate, "BadExpirationDate", None),
            (ErrorReason::BadMessageId, "BadMessageId", None),
            (ErrorReason::BadPriority, "BadPriority", None),
            (ErrorReason::BadTopic, "BadTopic", None),
            (ErrorReason::DeviceTokenNotForTopic, "DeviceTokenNotForTopic", None),
            (ErrorReason::DuplicateHeaders, "DuplicateHeaders", None),
            (ErrorReason::IdleTimeout, "IdleTimeout", None),
            (ErrorReason::InvalidPushType, "InvalidPushType", None),
            (ErrorReason::MissingDeviceToken, "MissingDeviceToken", None),
            (ErrorReason::MissingTopic, "MissingTopic", None),
            (ErrorReason::PayloadEmpty, "PayloadEmpty", None),
            (ErrorReason::TopicDisallowed, "TopicDisallowed", None),
            (ErrorReason::BadCertificate, "BadCertificate", None),
            (
                ErrorReason::BadCertificateEnvironment,
                "BadCertificateEnvironment",
                None,
            ),
            (ErrorReason::ExpiredProviderToken, "ExpiredProviderToken", None),
            (ErrorReason::Forbidden, "Forbidden", None),
            (ErrorReason::InvalidProviderToken, "InvalidProviderToken", None),
            (ErrorReason::MissingProviderToken, "MissingProviderToken", None),
            (ErrorReason::UnrelatedKeyIdInToken, "UnrelatedKeyIdInToken", None),
            (
                ErrorReason::BadEnvironmentKeyIdInToken,
                "BadEnvironmentKeyIdInToken",
                None,
            ),
            (ErrorReason::BadPath, "BadPath", None),
            (ErrorReason::MethodNotAllowed, "MethodNotAllowed", None),
            (ErrorReason::ExpiredToken, "ExpiredToken", None),
            (ErrorReason::Unregistered, "Unregistered", Some(1508249865488u64)),
            (ErrorReason::PayloadTooLarge, "PayloadTooLarge", None),
            (
                ErrorReason::TooManyProviderTokenUpdates,
                "TooManyProviderTokenUpdates",
                None,
            ),
            (ErrorReason::TooManyRequests, "TooManyRequests", None),
            (ErrorReason::InternalServerError, "InternalServerError", None),
            (ErrorReason::ServiceUnavailable, "ServiceUnavailable", None),
            (ErrorReason::Shutdown, "Shutdown", None),
        ];

        for error in errors.into_iter() {
            let response_data = match error.2 {
                None => json!({"reason": error.1}),
                Some(ts) => json!({"reason": error.1, "timestamp": ts}),
            };

            let response_string = serde_json::to_string(&response_data).unwrap();

            let response_body: ErrorBody = serde_json::from_str(&response_string).unwrap();

            let expected_body = match error.2 {
                None => ErrorBody {
                    reason: error.0,
                    timestamp: None,
                },
                Some(ts) => ErrorBody {
                    reason: error.0,
                    timestamp: Some(ts),
                },
            };

            assert_eq!(expected_body, response_body);
        }
    }
}
